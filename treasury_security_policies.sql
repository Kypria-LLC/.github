-- Crown Treasury Security Lockdown\n-- Ensures only the service role (Edge Functions) can write revenue data\n\n-- Create refresh function for materialized view\nCREATE OR REPLACE FUNCTION public.refresh_member_current_state()\nRETURNS void\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nBEGIN\n  REFRESH MATERIALIZED VIEW private.member_current_state;\nEND;\n$$;\n\n-- Grant execute permission to service role\nGRANT EXECUTE ON FUNCTION public.refresh_member_current_state() TO service_role;\n\n-- Revoke default permissions and establish strict access control\nREVOKE ALL ON TABLE public.webhook_audit_log FROM anon, authenticated;\nREVOKE ALL ON TABLE public.revenue_events FROM anon, authenticated;\n\n-- Grant controlled access\n-- Service role: Full access for webhook ingestion\nGRANT ALL ON TABLE public.webhook_audit_log TO service_role;\nGRANT ALL ON TABLE public.revenue_events TO service_role;\n\n-- Authenticated users: Read-only access for dashboards\nGRANT SELECT ON TABLE public.webhook_audit_log TO authenticated;\nGRANT SELECT ON TABLE public.revenue_events TO authenticated;\n\n-- Update RLS policies for webhook_audit_log\nDROP POLICY IF EXISTS "members cannot insert audit" ON public.webhook_audit_log;\nDROP POLICY IF EXISTS "webhook_audit: insert by service" ON public.webhook_audit_log;\n\n-- Only authenticated users can read their own audit logs\nCREATE POLICY "webhook_audit: authenticated read own" \nON public.webhook_audit_log FOR SELECT \nTO authenticated \nUSING ((SELECT auth.uid()) = canonical_user_id);\n\n-- Service role can insert audit logs (bypasses RLS automatically)\n-- No explicit policy needed for service_role as it bypasses RLS\n\n-- Update RLS policies for revenue_events  \nDROP POLICY IF EXISTS "members insert revenue (service role only)" ON public.revenue_events;\nDROP POLICY IF EXISTS "revenue_events: insert owner_or_service" ON public.revenue_events;\n\n-- Only authenticated users can read their own revenue\nCREATE POLICY "revenue_events: authenticated read own"\nON public.revenue_events FOR SELECT\nTO authenticated\nUSING ((SELECT auth.uid()) = canonical_user_id);\n\n-- Service role can insert revenue events (bypasses RLS automatically)\n-- No explicit policy needed for service_role as it bypasses RLS\n\n-- Create helper function to map external IDs to canonical users\nCREATE OR REPLACE FUNCTION public.map_external_to_canonical_user(\n  external_platform text,\n  external_id text\n)\nRETURNS uuid\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $$\nDECLARE\n  canonical_id uuid;\nBEGIN\n  -- TODO: Implement mapping logic based on your user identification strategy\n  -- This could query a mapping table or use profile metadata\n  \n  -- For now, return null - revenue events will be created without canonical_user_id\n  -- They can be linked later through admin tools or additional processing\n  RETURN NULL;\nEND;\n$$;\n\n-- Grant execute to service role for user mapping\nGRANT EXECUTE ON FUNCTION public.map_external_to_canonical_user(text, text) TO service_role;\n\n-- Create sequence grants for service role (needed for IDENTITY columns)\nGRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO service_role;\n\n-- Ensure service role can read from private schema for analytics\nGRANT USAGE ON SCHEMA private TO service_role;\nGRANT SELECT ON ALL TABLES IN SCHEMA private TO service_role;